---
title: "Temporal modelling"
subtitle: "SHARP Bayesian Modeling for Environmental Health Workshop"
author: "Robbie M. Parks"
date: "August 2023"
format: html
---

```{r, echo=FALSE, warning=FALSE, message=FALSE}
library(here)
library(tidyverse)
library(nimble)
library(bayesplot)
library(posterior)
library(hrbrthemes)

extrafont::loadfonts()
theme_set(theme_ipsum())

color_scheme_set(scheme = "viridis")

set.seed(2)
```

## Goal of this computing lab session

This lab will explore some key temporal modelling concepts, including linear slopes, seasonal terms, random walks, autoregressive models, and forecasting.

## Explore the mortality data

We will be using national death count data for Spain during 2010-2020 as taken from the paper:

V. Kontis, J.E. Bennett, __R.M. Parks__, __T. Rashid__, J. Pearson-Stuttard, P. Asaria, B. Zhou, M. Guillot, C.D. Mathers, Y.H. Khang, M. McKee and M. Ezzati. _Lessons learned and lessons missed: impact of the coronavirus disease 2019 (COVID-19) pandemic on all-cause mortality in 40 industrialised countries prior to mass vaccination_. Wellcome Open Research 2021, 6:279

Let's load in the data.
```{r}
data <- read_csv(here("data", "Spain", "data_spain.csv"))
data
```

Now let's summarise the data by week nationally
```{r}
data_national <- data |>
  group_by(week,week_of_year) |>
  summarise(
    deaths = sum(deaths),
    population = sum(population),
    t2m = mean(t2m),
    weekly_t2m_anomaly = mean(weekly_t2m_anomaly)
  ) |>
  mutate(week=dmy(week)) |>
  arrange(week) |>
  filter(year(week) < 2020) # avoiding COVID for now

data_national
```

Let's plot the number of deaths over time
```{r}
ggplot(data = data_national) + geom_point(aes(x = week, y = deaths))
```

Let's calculate crude death rates over time too
```{r}
data_national <- data_national |>
  mutate(rate = 100000 * deaths / population)
```

Let's plot the death rates over time
```{r}
ggplot(data = data_national) + geom_point(aes(x = week, y = rate))
```

Before running NIMBLE, extract data for week and center around zero for better MCMC performance, as well as extracting month from date
```{r}
data_national = data_national |>
  ungroup() |>
  mutate(month = month(week), weekc = row_number()) |>
  mutate(weekc = weekc - mean(weekc))
```

## Linear model over time

The first model we will create and assess is a linear model over time, which assumes that death rates are simply going up or down at a constant rate throughout our study.
This is very basic, but you should always start with basic models and work your way up from there.
Since we are dealing with count data, a Poisson model could make sense.

Priors
$$
\begin{split}
\alpha &\sim N(0, 10), \\
\beta_w &\sim N(0, 10)
\end{split}
$$

Likelihood
$$
\begin{split}
y_t &\sim \text{Pois}(\mu_t) \quad i = t,..., T \\
\log(\mu_t) &= \log(P_t) + \alpha + \beta_w t
\end{split}
$$

Let's write the NIMBLE code
```{r}
code_linear <- nimbleCode({
  # priors
  alpha ~ dnorm(0, sd = 10) # prior for alpha
  beta_week ~ dnorm(0, sd = 10) # prior for beta_week

  # likelihood
  for(t in 1:Nw) {
    deaths[t] ~ dpois(mu[t])
    log(mu[t]) <- log(population[t]) + alpha + beta_week * t
  }

  # exponentiate the estimated parameters to reverse the log-link function
  alpha_exp <- exp(alpha)
  beta_week_exp <- exp(beta_week)

  # what's the estimated annual rate of change?
  beta_year <- exp(52 * beta_week)
  beta_year_exp <- exp(beta_year)
})
```

Final preparation of data into lists
```{r}
constants <- list(Nw = nrow(data_national))
data <- list(deaths = data_national$deaths, population = data_national$population)
```

Set initial values for MCMC samples
```{r}
inits <- list(alpha = 0, beta_week = 0)
parameters_to_monitor <- c("alpha", "beta_week", "alpha_exp", "beta_week_exp", "beta_year", "beta_year_exp")
```

Let's run the model.
```{r}
tic = Sys.time()
nimbleMCMC_samples_linear <- nimbleMCMC(
  code = code_linear,
  data = data,
  constants = constants,
  inits = inits,
  monitors = parameters_to_monitor,
  niter = 10000,
  nburnin = 5000,
  setSeed = 1,
  samplesAsCodaMCMC = TRUE
)

toc =  Sys.time()
toc - tic
```

What is the summary of each estimated parameter from the Poisson model?
```{r}
summarise_draws(nimbleMCMC_samples_linear, default_summary_measures())
summarise_draws(nimbleMCMC_samples_linear, default_convergence_measures())
```
```{r}
mcmc_trace(nimbleMCMC_samples_linear)
```

We'll calculate the death rate from the model using the formula.
For simplicity, we'll use the mean of the samples.
Let's look at how the model fit
```{r}
linear_fit <- data_national |>
  mutate(
    .death_rate_fit = 100000 * exp(
      mean(nimbleMCMC_samples_linear[, "alpha"]) + mean(nimbleMCMC_samples_linear[, "beta_week"]) * nrow(data_national)
    )
  ) |>
  mutate(residuals = rate - .death_rate_fit)

linear_fit |>
  ggplot(aes(x = residuals)) +
  geom_point(aes(x = week, y = rate), size = 0.6) +
  geom_point(aes(x = week, y = .death_rate_fit), linewidth = 0.8, colour = "red")
```
Looks like it has fit as straight and flat line.

Now let's look at the residuals of the fit, which, if the model fits well, should be randomly distributed around zero without any obvious pattern.
```{r}
linear_fit |>
  ggplot(aes(x = residuals)) +
  geom_histogram()
```
The residuals don't look normally distributed.
There is definitely some more complexity we should add to the model.

## Linear model over time with random walk term

The residuals look like there may be a seasonal pattern, and so let us attempt to remove that by including a weekly random walk.
Let's also remove the linear slope, which was basically flat.

Priors
$$
\begin{split}
\alpha &\sim N(0, 10), \\
\sigma_{rw} &\sim N^+(1)
\end{split}
$$

Likelihood
$$
\begin{split}
y_t &\sim \text{Pois}(\mu_t) \quad i = t,..., T \\
\log(\mu_t) &= \log(P_t) + \alpha + \gamma_t \\
\gamma_t &\sim N(\gamma_{t-1}, \sigma_{rw})
\end{split}
$$

```{r}
code_weekly_random_walk <- nimbleCode({
  # priors
  alpha ~ dnorm(0, sd = 10)     # prior for alpha
  sigma_rw ~ T(dnorm(0, 1), 0, Inf) # half-normal prior for variance of weekly effects

  # likelihood
  for(t in 1:Nw) {
    deaths[t] ~ dpois(mu[t])
    log(mu[t]) <- log(population[t]) + alpha + rw[t]
  }

  # random walk over time
  rw[1] <- 0
  for (t in 2:Nw) {
    rw[t] ~ dnorm(rw[t-1], sigma_rw)
  }
})
```

Set initial values for MCMC samples
```{r}
inits <- list(alpha = -8.0, rw = rep(0, times = nrow(data_national)), sigma_rw = 1)
parameters_to_monitor <- c("alpha", "rw")
```

Let's run the model.
```{r}
tic = Sys.time()
nimbleMCMC_samples_week_random_walk <- nimbleMCMC(
  code = code_weekly_random_walk,
  data = data,
  constants = constants,
  inits = inits,
  monitors = parameters_to_monitor,
  niter = 80000,
  nburnin = 40000,
  setSeed = 1,
  samplesAsCodaMCMC = TRUE
)

toc =  Sys.time()
tic - toc
```

What is the summary of each estimated parameter from the Poisson model?
```{r}
summarise_draws(nimbleMCMC_samples_week_random_walk, default_summary_measures())
summarise_draws(nimbleMCMC_samples_week_random_walk, default_convergence_measures())
```
Convergence could be better if we ran for longer.

What do the random weekly terms looks like?
```{r}
mcmc_intervals(nimbleMCMC_samples_week_random_walk, regex_pars = c("rw")) +
  theme(axis.text.y = element_blank())
```

ROBBIE I GOT TO HERE

NOTE, FOR MODELS BELOW, `weeks` is now `Nw` in `constants`.


## Linear model over time with random walk term and overall linear temperature term

Let's see what adding a slope for temperature does
$$
y = max + c
$$

```{r}
code_weekly_random_walk_with_temperature <- nimbleCode({
  # priors for parameters
  alpha ~ dnorm(0, sd = 10) # prior for alpha
  beta_week ~ dnorm(0, sd = 10) # prior for beta_week
  beta_temperature ~ dnorm(0, sd = 10) # prior for beta_temperature
  sigma_rw ~ dunif(0, 10) # prior for variance of random walk over time

  # regression formula
  for(t in 1:weeks) {
    deaths[t] ~ dpois(mu[t])
    log(mu[t]) <- log(population[t]) + alpha + beta_week * t + beta_temperature * weekly_t2m_anomaly[t] + rw[t]
  }

  # random walk over time
  rw[1] <- 0
  for (t in 2:weeks) {
    rw[t] ~ dnorm(rw[t-1], sigma_rw)
  }

  # exponentiate the estimated parameters to reverse the log-link function
  alpha_exp <- exp(alpha)
  beta_week_exp <- exp(beta_week)
  beta_temperature_exp <- exp(beta_temperature)

  # what's the estimated annual rate of change?
  beta_year <- exp(52 * beta_week)
  beta_year_exp <- exp(beta_year)
})
```

Final preparation of data into lists
```{r}
constants <- list(weeks = nrow(data_national))

data <- list(deaths = data_national$deaths,
             population = data_national$population,
             weekly_t2m_anomaly = round(data_national$weekly_t2m_anomaly,1))
```

Set initial values for MCMC samples
```{r}
inits <- list(alpha = 0, beta_week = 0, beta_temperature = 0, rw=rep(0, times=nrow(data_national)), sigma_rw=1)
parameters_to_monitor = c('alpha','beta_week','alpha_exp','beta_week_exp','beta_year','beta_year_exp','beta_temperature','beta_temperature_exp')
```

Let's run the model. Theo: Again these don't converge so well please consider what we do as ideally I'd like to make all the iteration numbers the same for each run
```{r}
t0 = Sys.time()
nimbleMCMC_samples_week_random_walk_with_temperature <- nimbleMCMC(
  code = code_weekly_random_walk_with_temperature,
  data = data,
  constants = constants,
  inits = inits,
  monitors = parameters_to_monitor,
  niter = 100000,
  nburnin = 10000,
  setSeed = 1,
  samplesAsCodaMCMC = TRUE
)

t1 =  Sys.time()
t1 - t0
```

What is the summary of each estimated parameter from the Poisson model?
```{r}
summarise_draws(nimbleMCMC_samples_week_random_walk_with_temperature, default_summary_measures())
summarise_draws(nimbleMCMC_samples_week_random_walk_with_temperature, default_convergence_measures())
```

Now the samples look to be very tidily centred.
```{r}
mcmc_trace(nimbleMCMC_samples_week_random_walk_with_temperature)
```

What do the random weekly terms looks like? (Theo)
```{r}

```

## Linear model over time with random walk term and monthly random linear temperature term

Let's see what adding a slope for temperature does by each month
$$
y = max + c
$$

```{r}
code_weekly_random_walk_with_temperature_by_month <- nimbleCode({

  # priors for parameters
  alpha ~ dnorm(0, sd = 10) # prior for alpha
  beta_week ~ dnorm(0, sd = 10) # prior for beta_week
  sigma_rw ~ dunif(0, 10) # prior for variance of random walk over time
  sigma_temperature ~ dunif(0, 10) # prior for variance of temperature effects

  # regression formula
  for(t in 1:weeks) {
    deaths[t] ~ dpois(mu[t])
    log(mu[t]) <- log(population[t]) + alpha + beta_week * t + rw[t] + beta_temperature_month[month[t]] * weekly_t2m_anomaly[t]
  }

  # random walk over time
  rw[1] <- 0
  for (t in 2:weeks) {
    rw[t] ~ dnorm(rw[t-1], sigma_rw)
  }

  # monthly temperature random effect
  beta_temperature_month[1] <- 0
  for (m in 2:n_months) {
    beta_temperature_month[m] ~ dnorm(0, sigma_temperature)
  }

  # exponentiate the estimated parameters to reverse the log-link function
  alpha_exp <- exp(alpha)

  # what's the estimated annual rate of change?
  beta_year <- exp(52 * beta_week)
  beta_year_exp <- exp(beta_year)
})
```

Final preparation of data into lists
```{r}
constants <- list(weeks = nrow(data_national),
                  n_months = max(data_national$month),
                  month = data_national$month)

data <- list(deaths = data_national$deaths,
             population = data_national$population,

             weekly_t2m_anomaly = round(data_national$weekly_t2m_anomaly,1))
```

Set initial values for MCMC samples
```{r}
inits <- list(alpha = 0, beta_week = 0,
              rw=rep(0, times=nrow(data_national)), beta_temperature_month=rep(0, times=max(data_national$month)),
              sigma_rw=1,sigma_temperature=1)
parameters_to_monitor = c('alpha','beta_week','alpha_exp','beta_year','beta_year_exp','beta_temperature_month')
```

Let's run the model. (Theo: Again how to converge with niter)
```{r}
t0 = Sys.time()
nimbleMCMC_samples_week_random_walk_with_temperature_by_month <- nimbleMCMC(
  code = code_weekly_random_walk_with_temperature_by_month,
  data = data,
  constants = constants,
  inits = inits,
  monitors = parameters_to_monitor,
  niter = 100000,
  nburnin = 10000,
  setSeed = 1,
  samplesAsCodaMCMC = TRUE
)

t1 =  Sys.time()
t1 - t0
```

What is the summary of each estimated parameter from the Poisson model?
```{r}
summarise_draws(nimbleMCMC_samples_week_random_walk_with_temperature_by_month, default_summary_measures())
summarise_draws(nimbleMCMC_samples_week_random_walk_with_temperature_by_month, default_convergence_measures())
```

Now the samples look to be very tidily centred.
```{r}
mcmc_trace(nimbleMCMC_samples_week_random_walk_with_temperature_by_month)
```

## Linear model with autoregressive term over time (Theo: Is this worth doing? If so can you please adapt RW1 and implement?)
```{r}

```

## Forecasting (what might have happened in 2020 without COVID?) (Theo: Can you quickly implement this?)
```{r}

```
