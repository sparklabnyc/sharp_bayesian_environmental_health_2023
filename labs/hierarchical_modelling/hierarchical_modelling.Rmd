---
title: "Hierarchical modelling"
subtitle: "SHARP Bayesian Modeling for Environmental Health Workshop"
author: "Theo Rashid, Elizaveta Semenova"
date: "August 2023"
output: html_document
---

```{r echo=FALSE}
library(here)
library(tidyverse)
library(nimble)
library(posterior)
library(geojsonsf)
library(hrbrthemes)
library(colorspace)

extrafont::loadfonts()
theme_set(theme_ipsum())

set.seed(2)
```

This task will involve taking the England or Italy data and fitting a really basic hierarchical model.
It will follow your basic:

- Full pooling
- No pooling
- Partial pooling

Aka radon model example. https://www.tensorflow.org/probability/examples/Multilevel_Modeling_Primer
The difference being our subgroups will be regions of Italy.

## Exploratory data analysis

```{r}
data <- read_rds(here("data", "italy", "italy_mortality.rds"))
glimpse(data)
summary(data)
```

Let's collapse the time dimension for now and focus on estimating the death rate in the final year and the 9th month.

```{r}
data <- data |>
  mutate(provincia_id = data |> group_by(SIGLA) |> group_indices()) |>
  filter(year == 2018) |>
  filter(month == 9)
```

```{r}
data |>
  ggplot(aes(x = SIGLA, y = deaths)) +
  geom_jitter()
```

We have a variable `expected`, which gives a good approximation to the number of deaths
```{r}
data |>
  ggplot(aes(x = expected, y = deaths)) +
  geom_abline(slope = 1, intercept = 0, linewidth = 0.1) +
  geom_point(size = 0.3)
```

```{r}
data |>
  ggplot(aes(x = deaths / expected)) +
  geom_histogram()
```

Estimate the region-specific standardised mortality ratio.

## Full pooling model

Treat all regions the same and estimate a single national prevalence.

## No pooling model

Treat all regions separately and estimate each region separately with fixed effects.

## Partial pooling model

Varying intercepts model. Random effect grouping all regions.
Estimate hyperparamter sigma (explain how this is hierarchical)

```{r}
constants <- list(
  N = nrow(data),
  Np = max(data$provincia_id),
  province = data$provincia_id
)

inits <- list(
  alpha = 0,
  theta = rep(0, constants$Np),
  sigma_p = 1
)

nimble_data <- list(
  y = as.integer(data$deaths),
  E = data$expected
)
```
```{r}
partial_pooling_model <- nimbleCode({
  # priors
  alpha ~ dnorm(0, 5)
  sigma_p ~ T(dnorm(0, 1), 0, Inf) # half-normal

  for (j in 1:Np) {
    theta[j] ~ dnorm(0, sd = sigma_p)
  }

  # likelihood
  for (i in 1:N) {
    y[i] ~ dpois(mu[i])
    log(mu[i]) <- log(E[i]) + alpha + theta[province[i]]
  }
})
```

```{r}
partial_pooling_samples <- nimbleMCMC(
  code = partial_pooling_model,
  data = nimble_data,
  constants = constants,
  inits = inits,
  monitors = c("alpha", "sigma_p", "theta"),
  niter = 2000,
  nburnin = 1000,
  thin = 1,
  nchains = 2,
  setSeed = 1,
  progressBar = TRUE,
  WAIC = TRUE
)
```

Follow the Bayesian workflow – look at MCMC outputs, r-hat using `posterior`, traceplots using `bayesplot`
```{r}
partial_pooling_posterior <- c()
for (chain in partial_pooling_samples$samples) {
  partial_pooling_posterior <- c(partial_pooling_posterior, list(as.list(as_tibble(chain))))
}
partial_pooling_posterior <- as_draws_df(partial_pooling_posterior)
```

```{r}
summarise_draws(partial_pooling_posterior, default_summary_measures())
summarise_draws(partial_pooling_posterior, default_convergence_measures())
```

SMR is `alpha + theta[i]`

## A different prior on sigma for Bayesian workflow

Maybe try a different prior on sigma, something really weird/informative and wrong.
Run prior predictive simulation and show how it makes no sense
Fit the model and look at posterior
